# Практическое занятие №5. Вопросы виртуализации

П.Н. Советов, РТУ МИРЭА

## Задача 1

Исследование виртуальной стековой машины CPython.

Изучите возможности просмотра байткода ВМ CPython.

```
import dis

def foo(x):
    while x:
        x -= 1
    return x + 1

print(dis.dis(foo))
```

Опишите по шагам, что делает каждая из следующих команд (приведите эквивалентное выражение на Python):

 11           0 LOAD_FAST                0 (x)
              2 LOAD_CONST               1 (10)
              4 BINARY_MULTIPLY
              6 LOAD_CONST               2 (42)
              8 BINARY_ADD
             10 RETURN_VALUE  
           
## Решение  

`LOAD_FAST 0 (x)`  - загружает значение переменной x в стэк  
`LOAD_CONST 1 (10)` - загружает константу 10 в стэк  
`BINARY_MULTIPLY` - умножает x на 10  
`LOAD_CONST 2 (42)` - загружает константу 42 в стэк  
`BINARY_ADD` - возвращает результат из стэка, как результат выполнения стэка return (x * 10) + 42  

### Пример кода Python
```
def foo(x):
  return (x * 10) + 42  
```

## Задача 2

Что делает следующий байткод (опишите шаги его работы)? Это известная функция, назовите ее.

```
  5           0 LOAD_CONST               1 (1)
              2 STORE_FAST               1 (r)

  6     >>    4 LOAD_FAST                0 (n)
              6 LOAD_CONST               1 (1)
              8 COMPARE_OP               4 (>)
             10 POP_JUMP_IF_FALSE       30

  7          12 LOAD_FAST                1 (r)
             14 LOAD_FAST                0 (n)
             16 INPLACE_MULTIPLY
             18 STORE_FAST               1 (r)

  8          20 LOAD_FAST                0 (n)
             22 LOAD_CONST               1 (1)
             24 INPLACE_SUBTRACT
             26 STORE_FAST               0 (n)
             28 JUMP_ABSOLUTE            4

  9     >>   30 LOAD_FAST                1 (r)
             32 RETURN_VALUE
```
## Решение

`LOAD_CONST 1 (1)` - Загружает константу 1 в стек.  
`STORE_FAST 1 (r)` - Сохраняет 1 в переменную r, это начальное значение для результата.  
`LOAD_FAST 0 (n)` - Загружает значение переменной n.  
`LOAD_CONST 1 (1)` - Загружает константу 1.  
`COMPARE_OP 4 (>)` - Сравнивает, больше ли n чем 1.  
`POP_JUMP_IF_FALSE 30` - Если результат сравнения ложный (т.е., n <= 1), переходит к инструкции 30 (выход из функции).  
`LOAD_FAST 1 (r)` - Загружает текущее значение переменной r.  
`LOAD_FAST 0 (n)` - Загружает значение переменной n.  
`INPLACE_MULTIPLY` - Умножает r на n и сохраняет результат обратно в r.  
`STORE_FAST 1 (r)` - Сохраняет новый результат в r.  
`LOAD_FAST 0 (n)` - Загружает значение n.  
`LOAD_CONST 1 (1)` - Загружает 1.  
`INPLACE_SUBTRACT` - Уменьшает значение n на 1 и сохраняет результат в n.  
`STORE_FAST 0 (n)` - Сохраняет результат в переменной n.  
`JUMP_ABSOLUTE 4` - Переходит обратно к шагу 4 (повторяет цикл).  
`LOAD_FAST 1 (r)` - Загружает результат из переменной r.  
`RETURN_VALUE` - Возвращает значение переменной r.  

### Эквивалентная функция на Python
```
def factorial(n):
  r = 1
  while n > 1:
    r *= n
    n -= 1
  return r
```



## Задача 3

Приведите результаты из задач 1 и 2 для виртуальной машины JVM (Java) или .Net (C#).

## Решение

> Чтобы вывести байт-код для программы на Java, можно использовать утилиту javap, которая поставляется вместе с JDK. Она позволяет просмотреть байт-код любого класса, даже если он не содержит исходного кода.
> Для просмотра байт-кода класса нужно: 
> 1. Скомпилировать Java-класс в .class файл с помощью команды javac, например: javac MyClass.java.
> 2. Запустить javap с флагом -c, чтобы вывести байт-код класса: javap -c MyClass.

### Пример байткода для функции foo

`0   iload_0`         Загружает значение x  
`1   ifeq 6`          Переход, если x == 0  
`3   iload_0`         Загружает x  
`4   iconst_1`        Загружает 1  
`5   isub`            Вычитает 1 из x  
`6   goto 1`          Переход к шагу 1 (цикл продолжается)  
`9   iload_0`         Загружает x (после выхода из цикла)  
`10  iconst_1`        Загружает 1  
`11  iadd`            Добавляет 1 к x  
`12  ireturn`         Возвращает результат (x + 1)  

### Пример байткода для функции factorial

`0   iconst_1`       Инициализация r = 1  
`1   istore_1`       Сохраняем 1 в r  
`2   iload_0`        Загружаем n  
`3   iconst_1`       Загружаем 1  
`4   if_icmple 13`   Если n <= 1, переход к шагу 13 (выход из цикла)  
`7   iload_1`        Загружаем r  
`8   iload_0`        Загружаем n  
`9   imul`           Умножаем r на n  
`10  istore_1`       Сохраняем новый r  
`11  iload_0`        Загружаем n  
`12  iconst_1`       Загружаем 1  
`13  isub`           Вычитаем 1 из n  
`14  istore_0`       Сохраняем новый n  
`15  goto 2`         Переход к шагу 2  
`18  iload_1`        Загружаем итоговый r  
`19  ireturn`        Возвращаем результат  


## Задача 4

Работа с qemu. Скачать и установить ISO-образ Alpine Linux для виртуальных машин с официального сайта.
Создать с помощью qemu образ жесткого диска (опция -f qcow2). Объем диска 500 Мб.
Запустить Alpine Linux с CD-ROM.
Установить систему на sda. Изменить motd.
Загрузиться уже с sda.
Прислать полный список команд для установки и загрузки, а также скриншот с motd, где фигурируют ваши имя и фамилия.

## Задача 5

(после разбора на семинаре и написания у доски базовой части эмулятора древней игровой приставки CHIP-8)

1. Реализовать вывод на экран.
2. Добиться запуска Тетриса.
3. Реализовать ввод с клавиатуры.
4. Добиться успешной работы всех приложений.

[Архив эмулятора CHIP-8](chip.zip)

## Полезные ссылки

Compiler Explorer: https://godbolt.org/

Байткод CPython: https://docs.python.org/3/library/dis.html

QEMU для Windows: https://www.qemu.org/download/#windows
http://sovietov.com/tmp/mqemu.zip

Документация по QEMU: https://www.qemu.org/docs/master/system/index.html

Старая документация по QEMU (рус.): https://www.opennet.ru/docs/RUS/qemu_doc/

Образы Alpine Linux: https://alpinelinux.org/downloads/

Документация по игровому компьютеру CHIP-8: http://devernay.free.fr/hacks/chip8/C8TECH10.HTM

Учебник по созданию миниатюрной ОС: https://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf

Nasm: https://nasm.us/

Прерывания BIOS: http://www.ctyme.com/intr/int.htm

Игры в загрузочном секторе: https://github.com/nanochess/Invaders
